---
title: "Take-home Exercise 1"
description: |
  Analysing and Visualising Spatio-temporal Patterns of COVID-19 in DKI Jakarta, Indonesia
author:
  - name: Lye Jia Wei
    url: https://lye-jia-wei.github.io/
date: 08-30-2021
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
    toc_float: true
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


## 1. Introduction

Since late December 2019, an outbreak of a novel coronavirus disease (COVID-19; 
previously known as 2019-nCoV) was reported in Wuhan, China, which had 
subsequently affected 210 countries worldwide. In general, COVID-19 is an acute 
resolved disease but it can also be deadly, with a 2% case fatality rate.

The COVID-19 pandemic in Indonesia is part of the ongoing worldwide pandemic of 
coronavirus disease 2019 (COVID-19) caused by severe acute respiratory syndrome 
coronavirus 2 (SARS-CoV-2). The virus was confirmed to have reached Indonesia 
on March 2, 2020. It started with two cases in March. As of July 31 2021, there 
had been 3,409,658 cumulative confirmed cases of COVID-19 in Indonesia and 
94,119 reported cumulative deaths. All cases were spread in 34 provinces in 
Indonesia. Among all the provinces, DKI Jakarta (Indonesian: Daerah Khusus 
Ibukota Jakarta and in English: Special Capital Region of Jakarta) contributed 
close to 24% of the cumulative confirmed cases.



## 2. Problem Statement 

Given that the cumulative confirmed cases were not evenly distributed within DKI Jakarta, this geospatial analysis aims to

- 1. Reveal the spatial-temporal patterns of COVID-19 case in DKI Jakarta 
- 2. Find out sub-districts with relatively higher number of confirmed cases
- 3. Identify trends of COVID-19 case in the sub-districts and how they change over time.

## 3. Data

In this analysis, the following dataset were used:

```{r, layout="l-body",table.with=2}

Data <- c("Jakarta COVID-19 Data", "DKI Jarkata shapefile")
Format <- c("XLSX", "Shapefile")
Description <- c("Daily COVID-19 data of DKI Jakarta compiled monthly between March 2020 to July 2021", "Jakarta sub-district")
Source <- c("[Open Data Covid-19 Provinsi DKI](https://riwayat-file-covid-19-dki-jakarta-jakartagis.hub.arcgis.com/)",
"[Indonesia Geospatial Data](https://www.indonesia-geospasial.com/p/sitemap.html)")


data_set <- data.frame(Data,Description,Format, Source)

knitr::kable(head(data_set))
```
*Note: Jakarta COVID-19 data file for last day of each month is used with the 
exception of missing file for January 2021

## 4. Getting Started

In this exercise, the key R package use is tmap package in R. Beside
tmap package, seven other R packages will be used. They are:

- sf for handling geospatial data
- tidyverse for subsetting and transforming data 
- ReadXL for importing XLSX file
- plotly for data visualization
- dplyr for data maniupulation
- plyr for splitting, applying and combining data 
- tmap to produce thematic map
- spdep to create spatial weights matrix objects 

```{r echo=TRUE, eval=TRUE}
packages <- c('sf','tidyverse','readxl','plotly','dplyr','plyr','tmap','spdep')
for(p in packages){
  if(!require(p, character.only = T)){
    install.packages(p)
  }
  library(p, character.only = T)
}
```

## 5. Data Import

### 5.1 Importing Geospatial Data Into R

Import the data and examine the content of the data set.

- Data will first be imported as an sf object to facilitate data pre-processing 
and initial analysis, then converted to sp class in the later part of the 
analysis.

```{r echo=TRUE, eval=TRUE} 

DKI_Jakarta = st_read(dsn="data/geospatial",layer="BATAS_DESA_DESEMBER_2019_DUKCAPIL_DKI_JAKARTA")
```

The message above reveals that the geospatial objects are multipolygon features. 
There are a total of 269 multipolygon features and 161 fields in DKI_Jakarta simple 
feature data frame. DKI is in WGS84 projected coordinates systems. 


### 5.2 Importing Attribute Data Into R

Next, we will import monthly Covid-19 data XLSX file from a folder into RStudio 
and save it into an R dataframe called Covid_DF.

#### 5.2.1 Reading XLSX File

The task will be performed by using lapply() in combination with read_xlsx() 
function to identify all the xlsx file and then applying a function to 
transform the file in the File_List as shown in the code chunk below. We will 
also be adding 'Date' field to extract the date from file name in the subsequent step. 

```{r echo=TRUE, eval=TRUE} 

File_List <- list.files(path = "C:/Users/User/Desktop/IS415/lye-jia-wei/IS415_blog/_posts/2021-08-30-take-home-exercise-1/data/aspatial" , pattern = "*.xlsx",  full.names = T)

DF_List <- lapply(seq_along(File_List), function(x) transform(read_xlsx(File_List[x]), Date = File_List[x]))

```

#### 5.2.2 Creating Dataframe

We will then convert the DF_List into dataframe called Covid_DF using the ldpy 
function. This will be a temporary dataframe which we will then carry out data 
cleaning in the later step.

```{r echo=TRUE, eval=TRUE} 
Covid_DF <- ldply(DF_List, data.frame)
```


## 6. Data Extraction, Wrangling and Integration

### 6.1 Geospatial Data

#### 6.1.1 Data Cleaning 

First, we have to ensure that spatial data used for analysis has no invalid geometries.

```{r echo=TRUE, eval=TRUE}
length(which(st_is_valid(DKI_Jakarta) == FALSE))

```
- There are no invalid geometries in the data that needs to be handled.


Check the geospatial data for missing values, as missing values can impact future 
calculations.

```{r echo=TRUE, eval=TRUE}
DKI_Jakarta[rowSums(is.na(DKI_Jakarta))!=0,]
```
- From the output, we can see that object ID 25645 and 25646 has missing value
for the column 'KAB_KOTA' and 'KECAMATAN' amongst other column

- 'KODE DESA' format is inconsistent with the other data in the same column

Hence, we will proceed to drop the two rows with the following code chunk

```{r echo=TRUE, eval=TRUE} 

DKI_Jakarta <- na.omit(DKI_Jakarta,c("DESA_KELUR"))
```



#### 6.1.2 Plotting the Geospatial Data

Let us now quickly visualize the DKI_Jakarta dataframe 

```{r echo=TRUE, eval=TRUE} 
plot(DKI_Jakarta)
```
From the map, it is evident that DKI_Jakarta consists of outer islands which
is not part of our intended study area. We will look into that after we check
the projected coordination system.




#### 6.1.3 Define Projection

- The spatial data of Jakarta (Indonesia) is utilised in this analysis.

- Initial data exploration reveals that data is to be projected
with the World Geodetic System 1984 datum.
- The corresponding EPSG code is EPSG: 23845.
- The CRS of the data will be checked, then assigned accordingly.
- Unit of measurement will be in metres.

```{r echo=TRUE, eval=TRUE}
st_crs(DKI_Jakarta)
```
#### 6.1.4 Assigning a coordinate system 

Although DKI_Jakarta data frame is projected in WGS84 but when we read until 
the end of the print, it indicates that the EPSG is 4326. This is a wrong EPSG 
code because the correct EPSG code should be 23845.

In order to assign the correct EPSG code to DKI_Jakarta data frame as well
as to set the national projeted coordinates systems of Indonesia whhich is DGN95, 
st_transform is used as shown in the code chunk below.

```{r echo=TRUE, eval=TRUE}
DKI_Jakarta <- st_transform(DKI_Jakarta, 23845)

```

Let us check the CSR again to ensure that changes are reflected

```{r echo=TRUE, eval=TRUE}

st_crs(DKI_Jakarta)
```

- We have successfully assign DGN95:23845 as the projection for the data.


#### 6.1.5 Removing Outer Islands

To exclude all the outer islands from the DKI_Jakarta dataframe, we will plot
an interactive map to identify the mainland.

```{r echo=TRUE, results='hide'}

tmap_mode("view")
tm_shape(DKI_Jakarta)+
  tm_fill()
```

From the initial exploration, it can be found that Object_ID greater than 25383
consists of the island. Hence, we will proceed to filter them out using the code
chunk below.

```{r echo=TRUE, eval=TRUE}

DKI_Jakarta <- filter(DKI_Jakarta, OBJECT_ID > 25383)


```




#### 6.1.6 NA and Geometric Validity Checks 

To check if there are any NA values as a result of data manipulation in the previous step.

```{r echo=TRUE, eval=TRUE}
DKI_Jakarta[rowSums(is.na(DKI_Jakarta))!=0,]
```




#### 6.1.7 Retain the first nine fields in the DKI Jakarta sf data frame

Since we are only interested in the first nine fields of the DKI_Jakarta sf
dataframe, we will only retain these columns.

```{r echo=TRUE, eval=TRUE}

DKI_Jakarta <- DKI_Jakarta[, 0:9]
```

#### 6.1.8 Translating column name for DKI_Jakarta to English

For convenience and ease of comprehension, we will translate the DKI_Jakarta
column names to English by using tidyverse rename function. 

```{r echo=TRUE, eval=TRUE}

DKI_Jakarta <- DKI_Jakarta %>% 
  dplyr::rename(
    Total_Population=JUMLAH_PEN, Sub_District=DESA_KELUR, District=KECAMATAN, 
    City=KAB_KOTA, Province=PROVINSI, Village=DESA, ID=KODE,
    Village_Code=KODE_DESA, Object_ID=OBJECT_ID
    )

```

```{r echo=FALSE, eval=FALSE}

DKI_Jakarta$Total_Population <- as.numeric(DKI_Jakarta$Total_Population)
```


### 6.2 Aspatial Data


#### 6.2.1 Understanding Covid_DF

To better understand the data structure of Covid_DF, we will inspect it
quickly by looking at the first 5 rows. 

```{r echo=TRUE, eval=TRUE}
head(Covid_DF,5)
```

While combining the different XLSX file into the dataframe, it may have resulted in 
duplicated columns e.g Meninngal...26, Meninggal...30 which should be consolidated into
a single column. Hence, the next step is to remove these duplicated columns
and drop the column that we will not use in the analysis. 


#### 6.2.2 Coalesce 'ID_KEL' & 'Meninngal' column

A quick glance at dataframe suggest that there are duplicated  'ID_KEL' column.
Hence, we can use the coalesce function which finds the first non-missing value 
at each position to ensure that all the ID are present one single ID column. 

```{r echo=TRUE, eval=TRUE}

Covid_DF <- Covid_DF %>% 
  mutate(ID_KEL = coalesce(ID_KEL, ID_KEL...1, ID_KEL...2))

```


We will then repeat this step for the 'Meninngal' column. Before we 
coalesce the various Meninggal column, we will have to change the data 
type of the column to double as the original column is of different data type.


```{r echo=TRUE, eval=TRUE}

Covid_DF$Meninggal...26 = as.double(Covid_DF$Meninggal...26)

Covid_DF <- Covid_DF %>% 
  mutate(Meninggal = coalesce(Meninggal, Meninggal...28, Meninggal...29, Meninggal...30, Meninggal...31, Meninggal...26))

```

#### 6.2.3 Extract Column of Interest

While there are many columns in Covid_DF, the relevant columns for analysis
are: 

- Name_provinsi (Province)
- name_kota (City)
- nama_kecamatan (District)
- nama_kelurahan (Sub-district)
- Meninggal (Deaths)
- POSITIF (Covid Cases)
- Date
- ID

Hence, we will be only be retaining the 8 columns and this is done by selecting
these variables by their column name.

```{r echo=TRUE, eval=TRUE}

Covid_DF <- Covid_DF %>% select("Date","ID_KEL", 
                                          "Nama_provinsi", "nama_kota", 
                                          "nama_kecamatan", "nama_kelurahan", 
                                          "POSITIF", "Meninggal")

```


#### 6.2.4 Adding in 'Date' Column 

Since we are interested in the Covid-19 cases in Jakarta through time, it is
important to add a 'Date' column to identify the Covid-19 cases at different
point in time. 

A quick look at the XLSX file suggest that a pattern exist in the file names:

- XLSX File Name: Standar Kelurahan Data Corona (28 Februari 2021 Pukul 10.00).xlsx

- The date is formatted as DD-Month-YYY in bracket right before '(' and the word 'Pukul'

- Hence, we will use regular expressions to extract the date using the following
code chunk.

```{r echo=TRUE, eval=TRUE}

Covid_DF$Date <- str_extract(Covid_DF$Date,"(?<=Data Corona \\().*(?= Pukul)")

```


By looking through Covid_DF, we can see that the month is spelled in 
Bahasa Indonesia which is the national adminstrative language of Indonesia.
With that, we have to set locale to Indonesia and format the date.

```{r echo=TRUE, eval=TRUE}

Sys.setlocale(locale="ind")
Covid_DF$Date  <- c(Covid_DF$Date ) %>% as.Date(Covid_DF$Date , format ="%d %B %Y")

```
#### 6.2.5 Translating column name of Covid_DF to English

Next, we will translating column name to English for ease of comprehension using rename()

```{r echo=TRUE, eval=TRUE}

Covid_DF <- Covid_DF %>% 
  dplyr::rename(
    Death=Meninggal, Cases=POSITIF, Sub_District=nama_kelurahan, 
    District=nama_kecamatan, City=nama_kota, Province=Nama_provinsi, ID=ID_KEL
  )
```



#### 6.2.6 Dropping Columns 

Quick inspection of Covid_DF dataframe suggest that there are non-numeric
data in the "ID" column such as:

- BELUM DIKETAHUI
- PROSES UPDATE DATA
- LUAR DKI JAKARTA

Hence, we will proceed to drop these rows. 

```{r echo=TRUE, eval=TRUE}
Covid_DF <-Covid_DF[!is.na(Covid_DF$ID),]

Covid_DF <-Covid_DF [!(Covid_DF$ID=="BELUM DIKETAHUI" | Covid_DF$ID=="PROSES UPDATE DATA" | Covid_DF$ID=="LUAR DKI JAKARTA") ,]

```


## 7. Study Area 

To better understand the study area and Jakarta_Covid dataframe, tmap is used to plot
choropleth map to quickly visualize spatial relation of Covid-19 cases and 
deaths in Jakarta respectively.

### 7.1 Joining the Attribute Data & Spatial Data

We will use left_join() of dplyr to join the DKI_Jakarta dataframe and Covid_DF dataframe using the following common identifier:

- Province
- Sub-district
- City


```{r echo=TRUE, eval=TRUE}

Jakarta_Covid <- left_join(DKI_Jakarta, Covid_DF,
                          by = c("Province" = "Province","Sub_District" = "Sub_District",'City'='City'))

```



### 7.2 Preliminary Choropleth Map of Covid-19 Cases in Jakarta 

Next, we will plot the preliminary choropleth map of Covid-19 cases in Jakarta.
Note that this map is incomplete and is solely to visualize the geospatial data.

```{r echo=TRUE, eval=TRUE}

tmap_mode("plot")
tm_shape(Jakarta_Covid)+
  tm_fill("Cases",minimize = TRUE) +
  tm_borders(alpha = 0.5) 

```


### 7.3 Preliminnary Choropleth Map of Covid-19 Death in Jakarta 

We will repeat the same step for Covid-19 death column.

```{r echo=TRUE, eval=TRUE}

tmap_mode("plot")
tm_shape(Jakarta_Covid)+
  tm_fill("Death",minimize = TRUE) +
  tm_borders(alpha = 0.5) 

```

From the two maps, it is evident that there are missing cases and death data. 
Hence, in the following segment, we will be investigating the reason behind the
missing data and determine if additional data cleaning needs to be done.  


## 8. Data Inspection & Cleaning Round 2 

```{r echo = TRUE, eval = FALSE}

View(Jakarta_Covid)
View(DKI_Jakarta)
View(Covid_DF)
```

After inspecting the Jakarta_Covid dataframe, it appears that there are spelling
error for data in the 'Sub-District' column for DKI_Jakarta and Covid_DF
e.g 'KRAMAJATI' vs 'KRAMAT JATI' which resulted in missing data when joining 
the aspatial & spatial data.


### 8.1 Identifying Missing Sub-District

To establish a systematic way of checking for missing values, we will
compare the two data frame - DKI_Jakarta and Covid_DF. The following code chunk 
will identify the missing 'sub-district' value by comparing the two Sub-district
column of the two dataframe - Covid_DF and DKI_Jakarkta.

```{r echo=TRUE, eval=TRUE}
Covid_SD <-c(Covid_DF$Sub_District)
Jakarata_SD <-c(DKI_Jakarta$Sub_District)


Covid_SD[!(Covid_SD %in% Jakarata_SD)]

```
From the output, it is evident that the following sub-districts are spelled 
incorrectly:

- KRAMATJATI (Correct: 'KRAMAT JATI')
- PAL MERAH (Correct 'PALMERAH')
- PALMERIAM (Correct: 'PAL MERIAM')
- KALIBARU (Correct: 'KALI BARU')
- RAWAJATI (Correct: 'RAWA JATI')
- JATIPULO (Correct: 'JATI PULO')
- KRENDANG (Correct: 'KERENDANG')
- PINANGRANTI (Correct: 'PINANG RANTI')
- BALEKAMBANG (Correct: 'BALE KAMBANG')
- HALIM PERDANA KUSUMA (Correct: HALIM PERDANA KUSAMAH)
- KALI DERES (Correct: KALIDERES)


Apart from spelling mistakes,there were also sub-districts value that 
have missing word

- TENGAH (Correct: 'KAMPUNG TENGAH')


### 8.2 Clean Sub-District Data

The following code chunk corrects the misspelt sub-district in preparation for
joining the attribute data & spatial data in the next step. 

```{r echo=TRUE, eval=TRUE}
DKI_Jakarta <- DKI_Jakarta %>% mutate(Sub_District = ifelse(as.character(Sub_District) == "KRAMATJATI", "KRAMAT JATI", as.character(Sub_District)))
DKI_Jakarta <- DKI_Jakarta %>% mutate(District = ifelse(as.character(District) == "PAL MERAH", "PALMERAH", as.character(District)))
DKI_Jakarta <- DKI_Jakarta %>% mutate(Sub_District = ifelse(as.character(Sub_District) == "PALMERIAM", "PAL MERIAM", as.character(Sub_District)))
DKI_Jakarta <- DKI_Jakarta %>% mutate(Sub_District = ifelse(as.character(Sub_District) == "KALIBARU", "KALI BARU", as.character(Sub_District)))
DKI_Jakarta <- DKI_Jakarta %>% mutate(Sub_District = ifelse(as.character(Sub_District) == "RAWAJATI", "RAWA JATI", as.character(Sub_District)))
DKI_Jakarta <- DKI_Jakarta %>% mutate(Sub_District = ifelse(as.character(Sub_District) == "TENGAH", "KAMPUNG TENGAH", as.character(Sub_District)))
DKI_Jakarta <- DKI_Jakarta %>% mutate(Sub_District = ifelse(as.character(Sub_District) == "JATIPULO", "JATI PULO", as.character(Sub_District)))
DKI_Jakarta <- DKI_Jakarta %>% mutate(Sub_District = ifelse(as.character(Sub_District) == "KRENDANG", "KERENDANG", as.character(Sub_District)))
DKI_Jakarta <- DKI_Jakarta %>% mutate(Sub_District = ifelse(as.character(Sub_District) == "PINANGRANTI", "PINANG RANTI", as.character(Sub_District)))
DKI_Jakarta <- DKI_Jakarta %>% mutate(Sub_District = ifelse(as.character(Sub_District) == "BALEKAMBANG", "BALE KAMBANG", as.character(Sub_District)))
DKI_Jakarta <- DKI_Jakarta %>% mutate(Sub_District = ifelse(as.character(Sub_District) == "HALIM PERDANA KUSUMA", "HALIM PERDANA KUSUMAH", as.character(Sub_District)))
Covid_DF<- Covid_DF %>% mutate(District = ifelse(as.character(District) == "KALI DERES", "KALIDERES", as.character(District)))


```


### 8.3 Joining the Attribute Data & Spatial Data

To check the sub_district data, we will have to use left_join() of dplyr to join the DKI_Jakarta dataframe and Covid_DF dataframe again using common identifier which is 'sub_district' 

```{r echo=TRUE, eval=TRUE}

Jakarta_Covid <- left_join(DKI_Jakarta, Covid_DF,
                          by = c("Sub_District" = "Sub_District"))

```


### 8.4 Checking Sub-District Data

Plotting the cases against the map of Jakarta to verify that all the misspelled
sub-district and district are corrected.

```{r echo=TRUE, eval=TRUE}
tmap_mode("plot")
tm_shape(Jakarta_Covid)+
  tm_fill("Cases") +
  tm_borders(alpha = 0.5) 
```

- From the output, we can see that all the sub-district data are now corrected. 


## 9. Writing and Reading RDS

### 9.1 Writing RDS

Next, we will use the write_rds() function to export the data frame. 

```{r echo = TRUE, eval = FALSE}

write_rds(Covid_DF, file ="Covid_DF.rds")
write_rds(DKI_Jakarta, file ="DKI_Jakarta.rds")
```

### 9.2 Read RDS

Afterwhich, we will read the RDS. 

```{r echo = TRUE, eval = FALSE}

Covid_DF <- read_rds("/data/rds/Covid_DF.rds")
DKI_Jakarta <- read_rds("/data/rds/DKI_Jakarta.rds")

```


## 10. Exploratory Data Analysis

Before moving on to thematic mapping, we will quickly calculate the 
cumulative case rate to better understand the trend over time. 


```{r echo=TRUE, eval=TRUE}

Case_Rate <- Covid_DF %>%
  inner_join(DKI_Jakarta, by=c("Sub_District" = "Sub_District")) %>%
  group_by(Sub_District, Date) %>%
  dplyr::summarise(`Cuml_Case_Rate` =  ((sum(Cases) / (Total_Population ))*10000)) %>%
  ungroup() %>% pivot_wider(names_from = Date,
              values_from = Cuml_Case_Rate)


summary(Case_Rate)
```
- Based on summary statistics,  there is generally an increase in the number of 
COVID-19 cases in Jakarta with time between March 2020 and July 2021 , as 
observed from the increasing mean COVID-19 case rates across the months.

- Over time, we can also start to growing differences (range) in cumulative case rate 
between the maximum and minimum value.

- From the statistic alone, it can be inferred that there are sub-district in
Jakarta with zero COVID-19 cases till 30 June 2020.

To explore the spatial relationship between Covid-19 case rate and sub-district
in Jakarta, we will move on to the next segment on thematic mapping.


## 11. Thematic Mapping 

To better understand the spatio-temporal distribution of COVID-19 at the sub_district level, choropleth mapping techniques will be utilised for the analysis.

Choropleth maps visualising the spatial distribution of COVID-19 rates across sub_district in Jakarta, will be plotted across time (March 2020 to July 2021).
Covid Cases Per 10k Population will be visualised instead of the number of COVID-19 cases to standardised population sizes for a more holistic comparison.

#### 11.1 Cumulative Confirmed Cases 

##### 11.1.1 Data preparation

The following code chunk will use left_join() of dplyr to join the geographical
data (DKI_Jakarta) and attribute table (Covid_DF) using sub-district as the common identifier.


Following which, it will be group by sub-district and date as we are interested
to see the change in COVID-19 case rate over time at sub-district level.


Finally, the cumulative confirmed cases per 10,0000 population will be
calculated using summarise function of dplyr using the following formula:

$$ Monthly\ Cumulative\ Confirmed\ Cases\  = 
\frac{Total\ no\ of\ Covid-19\ cases\ at\ Sub-District\ 
Level}{Total\ Population\ of\ the\ Sub-District} \ *\ 10,000$$

After which, we will then covert Jakarta_Covid_Cases into sf.  

```{r echo=TRUE, eval=TRUE}

Jakarta_Covid_Cases <- Covid_DF %>%
  inner_join(DKI_Jakarta, by=c("Sub_District"="Sub_District")) %>%
  group_by(Sub_District, Date) %>%
  dplyr::summarise(`Cases Per 10k Population` = ((sum(Cases) / (Total_Population ))*10000)) %>% ungroup()

Jakarta_Covid_Cases <- Jakarta_Covid_Cases%>% left_join(DKI_Jakarta, 
                       by=c("Sub_District"="Sub_District"))

Jakarta_Covid_Cases<- st_as_sf(Jakarta_Covid_Cases)

```



          
##### 11.1.2 Plotting Choropleth Map of Monthly Cumulative Confirmed Cases 



*Classification Method*

Custom breaks will have to be specified explicitly to construct the classification 
scheme for Covid Cases Per 10k Population.

To guide the specification of breakpoints, descriptive statistics of Covid Cases 
Per 10k Population across months are first computed and studied.

```{r echo=TRUE, eval=TRUE}

summary(Jakarta_Covid_Cases["Cases Per 10k Population"]) 
```

- It can be observed that Covid Cases Per 10k Population rate range from 0 to 3808 across sub district, from March 2020 to July 2021.

*Break Point*

To choose an appropriate number of classes, we will use the sturges formula
$$ No\ of\ Classes = 1 + 1.32 * Log (Number\ of \ Values)$$

```{r echo=TRUE, eval=TRUE}
Classes=1+ 1.32* log(4176)
Classes
```
Taking into account the result and considering legibility, we will set the 
number of classes to be 7

```{r echo=TRUE, eval=TRUE}
Classes=1+ 1.32* log(4176)
Classes
```
In the code chunk below, tm_shape() is used to define the input data 
(Jakarta_Covid_Cases) and tm_fill() is used to illustrate the monthly cumulative
confirmed cases at sub-district level. 


The choropleth map is plotted with custom classification scheme for the month
of March 2020, as this was the first month which COVID-19 was first detected in Jakarta. 

```{r echo = TRUE, eval = FALSE}
Jakarta_Covid_Cases_March <- Jakarta_Covid_Cases %>% filter(Date == "2020-03-31")


tmap_mode("plot")+
tm_shape(Jakarta_Covid_Cases_March)+
tm_fill("Cases Per 10k Population", breaks = c(0, 4, 13, 53, 119, 270, 395, 3808), 
legend.is.portrait = TRUE) +
tm_borders(alpha = 0.5) +
tm_layout(main.title = "Cumulative Confirmed Cases per 10,000 population \n of Jakarta sub-district - March 2020" ,
            main.title.position = "center",
            main.title.size = 3.0,title.size = 3.00,
            legend.outside = FALSE,legend.title.size = 2.90, legend.text.size = 2.60,
            legend.position = c("left", "bottom"),
            frame = TRUE)+
  tm_compass(type="4star", size = 8) + 
  tm_scale_bar(width = 0.15,text.size = 1.50)+
  tm_grid(lwd = 0.1, alpha = 0.2,labels.size=2.00) 

``` 


```{r fig.width=26, fig.height=20}


Jakarta_Covid_Cases_March <- Jakarta_Covid_Cases %>% filter(Date == "2020-03-31")


tmap_mode("plot")+
tm_shape(Jakarta_Covid_Cases_March)+
tm_fill("Cases Per 10k Population", breaks = c(0, 4, 13, 53, 119, 270, 395, 3808), 
legend.is.portrait = TRUE) +
tm_borders(alpha = 0.5) +
tm_layout(main.title = "Cumulative Confirmed Cases per 10,000 population \n of Jakarta sub-district - March 2020" ,
            main.title.position = "center",
            main.title.size = 3.0,title.size = 3.00,
            legend.outside = FALSE,legend.title.size = 2.90, legend.text.size = 2.60,
            legend.position = c("left", "bottom"),
            frame = TRUE)+
  tm_compass(type="4star", size = 8) + 
  tm_scale_bar(width = 0.15,text.size = 1.50)+
  tm_grid(lwd = 0.1, alpha = 0.2,labels.size=2.00) 

```

- A darker shade of oranange indicates a higher COVID-19 rate per 10k population.

- From the choropleth map, it can observe that in March 2020, the sub-district with 
about 13 to 53 cases is around south-west Jakarta, specifically the sub-district Senayan 

- It is also interesting to note that sub_district near Senayan such as Gelora 
and Karet Semmangi, Rawa Barat also appears to have a slightly higher COVID-19 rate per 10k population
compared to other sub-district.




##### 11.1.3 Time-series choropleth map of COVID-19 Rates


For this segment, we hope to see the spatial-temporal patterns 
of COVID-19 case in DKI Jakarta between March 2020 to July 2021.

Again, tm_shape() is used to define the input data (Jakarta_Covid_Cases) and 
tm_fill() is used to illustrate the monthly cumulative confirmed cases at sub-district level.
Tm_facet() will be used to specify facets (small multiples) which will group
the data by time period of the COVID-19 case rate. 

```{r echo = TRUE, eval = FALSE}

tm_shape(Jakarta_Covid_Cases) +
  tm_fill("Cases Per 10k Population", breaks = c(0, 4, 13, 53, 119, 270, 395, 3808),
          thres.poly = 0,palette = "Reds") + 
  tm_facets(by="Date", 
            free.coords=TRUE, 
            drop.shapes=TRUE) +
  tm_layout(legend.show = TRUE,
            title.position = c("center", "center"), 
            main.title.size = 4,main.title = "Cumulative Covid-19 Rate In Jakarta Sub-District", legend.outside = FALSE,legend.width = 0.70, legend.text.size = 1.80, legend.title.size = 1.80, legend.position = c("left", "bottom"), panel.label.size = 2.5) +
  tm_compass(type="4star", size = 4) + 
  tm_scale_bar(width = 0.11,text.size = 1.80)+
  tm_grid(lwd = 0.1, alpha = 0.2,labels.size=1.50) +
  tm_borders(alpha = 0.5)


```

```{r fig.width=20, fig.height=35}

tm_shape(Jakarta_Covid_Cases) +
  tm_fill("Cases Per 10k Population", breaks = c(0, 4, 13, 53, 119, 270, 395, 3808),
          thres.poly = 0,palette = "Reds") + 
  tm_facets(by="Date", 
            free.coords=TRUE, 
            drop.shapes=TRUE) +
  tm_layout(legend.show = TRUE,
            title.position = c("center", "center"), 
            main.title.size = 4,main.title = "Cumulative Covid-19 Rate In Jakarta Sub-District", legend.outside = FALSE,legend.width = 0.70, legend.text.size = 1.80, legend.title.size = 1.80, legend.position = c("left", "bottom"), panel.label.size = 2.5) +
  tm_compass(type="4star", size = 4) + 
  tm_scale_bar(width = 0.11,text.size = 1.80)+
  tm_grid(lwd = 0.1, alpha = 0.2,labels.size=1.50) +
  tm_borders(alpha = 0.5)


```
- It can be observed that COVID-19 cases seem to spread outwards to the neighbouring sub-district with time.

- In the first 3 month (Mar 2020 - May 2020), it appears that COVID-19 cases are mostly concentrated around central and western Jakarta. 

- By August 2020, sub-district with the highest COVID-19 cases per 10k population (darker red areas) are mostly found in central jakarta 

- In the first half of 2021, COVID-19 cases per 10k population appears to spread throughout Jakarta. However, it is to noted that due to the
large class interval of 395 to 3808, difference between the various sub_district may not be apparently from April 2021 onwards. 

- On the whole, COVID-19 case rate increases across sub-district through time. 


##### 11.1.4 Animated Time-series choropleth map of COVID-19 Rates

To better visualize the changes across the various sub-district through time,
we will plot an animated map with the same data using the tmap_animation() function
to better visualize the changes in sub-district through time. 

The output will be saved in gif format. 

```{r echo = TRUE, eval = FALSE}


Covd_Cases_Animation= tm_shape(Jakarta_Covid_Cases)+ tm_fill("Cases Per 10k Population", breaks = c(0, 4, 13, 53, 119, 270, 395, 3808) ,palette = "Reds") +  tm_facets(along = "Date", free.coords = FALSE)
  
  
tmap_animation(Covd_Cases_Animation,file="C:/Users/User/Desktop/IS415/lye-jia-wei/IS415_blog/_posts/2021-08-30-take-home-exercise-1/AnimatedMap/Covid_Case_Animation.gif" , delay = 45)


```
*Cumulative Confirmed Cases per 10k population In Jakarta Sub-District From Mar 2020 - Jul 2021*

![](C:/Users/User/Desktop/IS415/lye-jia-wei/IS415_blog/_posts/2021-08-30-take-home-exercise-1/AnimatedMap/Covid_Case_Animation.gif)




#### 11.2 Cumulative Covid-19 Death

##### 11.2.1 Data Preparation

After understanding the COVID-19 case rate, we will now look into the death
rate at sub-district level. 


The following code chunk will use left_join() of dplyr to join the geographical
data (DKI_Jakarta) and attribute table (Covid_DF) using sub-district as the common identifier.


Following which, it will be group by sub-district and date and we will calculate
the cumulative death per 10,0000 population using summarise function of dplyr with 
the following formula:



$$ Monthly\ Cumulative\ Confirmed\ Death\  = 
\frac{Total\ no\ of\ Covid-19\ Death\ at\ Sub-District\ 
Level}{Total\ Population\ of\ the\ Sub-District} *\ 10,000$$

After which, we will then covert Jakarta_Covid_Cases into sf. 


```{r echo=TRUE, eval=TRUE}


Jakarta_Death <- Covid_DF %>%
  inner_join(DKI_Jakarta, by=c("Sub_District"="Sub_District")) %>%
  group_by(Sub_District, Date) %>%
  dplyr::summarise(`Death Per 10k Population` = ((sum(Death) / (Total_Population)))* 10000)  %>% ungroup()

Jakarta_Death  <- Jakarta_Death %>% left_join(DKI_Jakarta, 
                       by=c("Sub_District"="Sub_District"))

Jakarta_Death <- st_as_sf(Jakarta_Death)



```


##### 11.2.2 Plotting Choropleth Map of Monthly Cumulative Death


*Classification Method*

Custom breaks will have to be specified explicitly to construct the classification 
scheme for Covid Death Per 10k Population.

To guide the specification of breakpoints, descriptive statistics of 
Covid Death Per 10k Population across months is first computed and studied.

```{r echo=TRUE, eval=TRUE}

summary(Jakarta_Death["Death Per 10k Population"]) 
```

- It can be observed that Covid Death Per 10k population rate range from 0 to 42 across sub district, from March 2020 to July 2021.

*Break Point*

To choose an appropriate number of classes, we will use the sturges formula
$$ No\ of\ Classes = 1 + 1.32 * Log (Number\ of \ Values)$$

```{r echo=TRUE, eval=TRUE}
Classes=1+ 1.32* log(4176)
Classes
```
With the result and considering legibility, we will set the number of classes to 
be 7



The choropleth map is plotted with custom classification scheme. To compare
with the previous map, we will also filter the date to be March 2020. 

tm_shape() is used to define the input data (Jakarta_Death) and 
tm_fill() is used to illustrate the monthly cumulative death at sub-district level.


```{r echo = TRUE, eval = FALSE}
Jakarta_Death_March <- Jakarta_Death %>% filter(Date == "2020-03-31")

tmap_mode("plot")+
tm_shape(Jakarta_Death_March)+
tm_fill("Death Per 10k Population", breaks = c(0, 2, 4, 6, 8, 10, 12, 14), 
legend.is.portrait = TRUE) +
tm_borders(alpha = 0.5) +
tm_layout(legend.outside = FALSE,legend.title.size = 3.10, legend.text.size = 2.90,
            legend.position = c("left", "bottom"),
            frame = TRUE, main.title = "Cumulative Death per 10k population in Jakarta Sub-district(Mar 2020)", main.title.size = 4)+
  tm_compass(type="4star", size = 8) + 
  tm_scale_bar(width = 0.15,text.size = 1.50)+
  tm_grid(lwd = 0.1, alpha = 0.2,labels.size=2.00) 

```


```{r fig.width=26, fig.height=22}


Jakarta_Death_March <- Jakarta_Death %>% filter(Date == "2020-03-31")

tmap_mode("plot")+
tm_shape(Jakarta_Death_March)+
tm_fill("Death Per 10k Population", breaks = c(0, 2, 4, 6, 8, 10, 12, 14), 
legend.is.portrait = TRUE) +
tm_borders(alpha = 0.5) +
tm_layout(legend.outside = FALSE,legend.title.size = 3.10, legend.text.size = 2.90,
            legend.position = c("left", "bottom"),
            frame = TRUE, main.title = "Cumulative Death per 10k population in Jakarta Sub-district(Mar 2020)", main.title.size = 4)+
  tm_compass(type="4star", size = 8) + 
  tm_scale_bar(width = 0.15,text.size = 1.50)+
  tm_grid(lwd = 0.1, alpha = 0.2,labels.size=2.00) 

```

- From the map, it can be seen that Gondangdia and Senayan are the only 2 sub-district with 
about 2 to 4 Covid death in March 2020. 


##### 11.2.3 Time-series choropleth map of COVID-19 Rates


By using tm_facet() and grouping by date in tm_facets(), we can see the spatial-temporal patterns 
of COVID-19 death in DKI Jakarta between March 2020 to July 2021.

```{r echo = TRUE, eval = FALSE}

tm_shape(Jakarta_Death) +
  tm_fill("Death Per 10k Population", breaks = c(4, 8, 12, 16, 20, 24, 28, 32),
          thres.poly = 0,palette = "Reds") + 
  tm_facets(by="Date", 
            free.coords=TRUE, 
            drop.shapes=TRUE) +
  tm_layout(legend.show = TRUE, title.position = c("center", "center"), main.title.size = 4, main.title = "   Cumulative Covid-19 Death Rate In Jakarta Sub-District",  legend.outside = FALSE,legend.width = 0.70, legend.text.size = 1.80, legend.title.size = 1.80, legend.position = c("left", "bottom"), panel.label.size = 2.5) +
  tm_compass(type="4star", size = 4) + 
  tm_scale_bar(width = 0.10,text.size = 1.80)+
  tm_grid(lwd = 0.1, alpha = 0.2,labels.size=1.50) +
  tm_borders(alpha = 0.5)







```

```{r fig.width=20, fig.height=35}

tm_shape(Jakarta_Death) +
  tm_fill("Death Per 10k Population", breaks = c(4, 8, 12, 16, 20, 24, 28, 32),
          thres.poly = 0,palette = "Reds") + 
  tm_facets(by="Date", 
            free.coords=TRUE, 
            drop.shapes=TRUE) +
  tm_layout(legend.show = TRUE, title.position = c("center", "center"), main.title.size = 4, main.title = "   Cumulative Covid-19 Death Rate In Jakarta Sub-District",  legend.outside = FALSE,legend.width = 0.70, legend.text.size = 1.80, legend.title.size = 1.80, legend.position = c("left", "bottom"), panel.label.size = 2.5) +
  tm_compass(type="4star", size = 4) + 
  tm_scale_bar(width = 0.10,text.size = 1.80)+
  tm_grid(lwd = 0.1, alpha = 0.2,labels.size=1.50) +
  tm_borders(alpha = 0.5)







```


- From the map, it is evident that despite the high covid case per 10k population
shown earlier, there is a  stark contrast with the map depicitng covid death per 10k population. This may suggest that Covid-19 death rate is relatively low in the earlier period when COVID-19 was spreading in Jakarta sub-district e.g March 2020 to Dec 2020

- By Feb 2021, one particular sub-district, Gambir, stood out as it is the only sub-district with a relatively high (28-32) death per 10k population 

- Death per 10k population increases sharply after May 2021 and appears to be higher in Central Jakarta. The sharp rise in death per 10k population may
be a result of the more fatal Covid-19 Delta variant, though additional statistical testing needs to be conducted to prove this hypothesis. 



##### 11.2.4 Animated Time-series choropleth map of COVID-19 Rates

To better visualize the changes in death rate across the various sub-district through time,
we will plot an animated map with the same data using tmap_animation().

```{r echo = TRUE, eval = FALSE}


Covd_Death_Animation = tm_shape(Jakarta_Death)+ tm_fill("Death Per 10k Population", breaks = c(4, 8, 12, 16, 20, 24, 28, 32) ,palette = "Reds") +  tm_facets(along = "Date", free.coords = FALSE)
  
  
tmap_animation(Covd_Death_Animation, delay = 45)
```

*Cumulative Death Rate In Jakarta Sub-District From Mar 2020 - Jul 2021*

![](C:/Users/User/Desktop/IS415/lye-jia-wei/IS415_blog/_posts/2021-08-30-take-home-exercise-1/AnimatedMap/Covd_Death_Animation.gif)

## 12. Analytical Map

### 12.1 Barchart

To better understand specific sub-district which has been affected by COVID-19 
the most in terms of infection rate and death rate, we will now proceed to
plot bar chart that shows the top 10 district with highest Covid-19 case rate
and death rate from March 2020 to July 2021. 


#### 12.1.1 Bar Chart of Top 10 Sub-District With Highest Covid-19 Cases Per 10,000 Population

##### 12.1.1.1 Combining aspatial and spatial dataframe

First, we will filter to the most recent date which is July 2021.

Again, we will combine the Covid_DF and DKI_Jakarta data frame by common identifier 'Sub_District'
using the left_join() of dplyr. We will use the aforementioned formula to
calculate the Covid cases per 10,000 population and it will be named as 'Covid_Case_10K'.

Note that this time round, we will only group by sub-district as we are interested
to find out the overall case rate at sub-district level.

```{r echo=TRUE, eval=TRUE}
Covid_DF_2<- Covid_DF %>% filter(Date == "2021-07-31")
Jakarta_Covid_Sub_District <- Covid_DF_2 %>%
  left_join(DKI_Jakarta, by=c("Sub_District"="Sub_District")) %>%
  group_by(Sub_District) %>% 
  dplyr::summarise(`Covid_Case_10k` =((sum(Cases) / (Total_Population ))*10000)) %>% ungroup()

```

##### 12.1.1.2 Dropping Duplicated Rows and Rounding Up

Next, we will get drop the duplicated row as well as 
to round the result to nearest number.

```{r echo=TRUE, eval=TRUE}

Jakarta_Covid_Sub_District <-Jakarta_Covid_Sub_District[!duplicated(Jakarta_Covid_Sub_District), ]

Jakarta_Covid_Sub_District$Covid_Case_10k <- round(Jakarta_Covid_Sub_District$Covid_Case_10k ,0)
```

##### 12.1.1.3 Plotting barchart 

Following which, we will sort the sub_district by covid cases per 10k population
and only plot the bar chart for the top 10 sub_district with highest covid cases using ggplot. 

```{r echo=TRUE, eval=TRUE}

top_n(Jakarta_Covid_Sub_District, n=10, Covid_Case_10k) %>%
          ggplot(., aes(x=Covid_Case_10k, y=reorder(Sub_District, Covid_Case_10k),label= (Covid_Case_10k)))+
              geom_bar(stat='identity')+ 
  geom_col(fill='darksalmon') +
  labs(title='Top 10 Sub-District With Highest Covid-19 Case Rate',
       x='Cases per 10k',
       y='Sub-District') +
  geom_text(nudge_x=-115.85,vjust = 0.5, colour='gray23', size=2.87) +
  theme_minimal()

```

- From the barchart, we can see that Gambir is the sub district with the highest
Covid-19 cases per 10k population in Jakarta between March 2020 and July 2021. 

- To note that the top 3 sub-districted highlighted in the barchart
are located close to each other as seen from the Choropleth map. We will study the geospatial relationship
further in the later part of the analysis. 


#### 12.1.2 Bar Chart of Top 10 Sub-District With Highest Covid-19 Death Per 10,000 Population

##### 12.1.2.1 Combining aspatial and spatial dataframe

Again, we will combine the Covid_DF and DKI_Jakarta data frame by  common identifier 'Sub_District'.
We will use the same formula to calculate the Covid death per 10,000 population and it will be named as 'Death_Per_10K'.

```{r echo=TRUE, eval=TRUE}

Jakarta_Death_Sub_District <- Covid_DF_2 %>%
  left_join(DKI_Jakarta, by=c("Sub_District"="Sub_District")) %>%
  group_by(Sub_District) %>% 
  dplyr::summarise(Death_Per_10k = ((sum(Death) / (Total_Population ))*10000)) %>% ungroup()

```

##### 12.1.2.2 Dropping duplicated rows and Rounding Up

Next, we will get drop the duplicated row and round the result to nearest number. 

```{r echo=TRUE, eval=TRUE}

Jakarta_Death_Sub_District <-Jakarta_Death_Sub_District[!duplicated(Jakarta_Death_Sub_District), ]

Jakarta_Death_Sub_District$Death_Per_10k <- round(Jakarta_Death_Sub_District$Death_Per_10k ,0)
```

##### 12.1.2.3 Bar Chart

Following which, we will sort the sub_district by COVID-19 death per 10k population
and only plot the top 10 sub_district with highest COVID-19 death using ggplot. 

```{r echo=TRUE, eval=TRUE}

top_n(Jakarta_Death_Sub_District, n=10, Death_Per_10k) %>%
          ggplot(., aes(x=Death_Per_10k, y=reorder(Sub_District, Death_Per_10k),label= (Death_Per_10k)))+
              geom_bar(stat='identity')+ 
  geom_col(fill='darksalmon') +
  labs(title='Top 10 Sub-District With Highest Covid-19 Death',
       x='Death per 10k',
       y='Sub-District') +
  geom_text(nudge_x=-0.85,vjust = 0.5, colour='gray23', size=2.87) +
  theme_minimal() + theme(plot.title = element_text(size=10))



```

- As pointed out previously in the Choropleth map, Gambir has one of the highest Covid-19 death per 10k population 

- Again, we can observe that the top sub-district with highest Covid-19 death per 10k population appears to be geographically near to one another as pointed out in earlier analysis 

- To note, the top 10 district with highest Covid-19 cases and Covid-19 death per 10k population differs slightly. 


### 12.2 Box Map 

A box map will be used to visualise covid cases spatially across different sub-district
in Jakarta. 

A customised classification scheme for the choropleth map will be constructed 
using the basic principles of a box plot.This ensures that data classification 
is not manipulated, and that the data is visualised accurately to represent 
the real-world situation. The box map will enable statistical interpretation 
of outliers and better identification of subzones that have relatively higher 
or lower demand compared to the rest of the subzones. In this analysis, data 
points will be considered outliers if they are more than 1.5 times interquartile 
range.


The following code chunks are functions to construct the box map which consist of

- boxbreaks to create break points for box map
- get.var to extract variable as vector out of dataframe
- Boxmap function with points overlayed on top of choropleth map

```{r echo=TRUE, eval=TRUE}


# To create break points for box map

boxbreaks <- function(v, mult=1.5) {
  qv <- unname(quantile(v))
  iqr <- qv[4] - qv[2]
  # upfence and lofence define the area where points will be defined as outliers
  upfence <- qv[4] + mult * iqr
  lofence <- qv[2] - mult * iqr
  # initialize break points vector
  bb <- vector(mode="numeric",length=7)
  # logic for lower and upper fences
  if (lofence < qv[1]) { # no lower outliers
  bb[1] <- lofence
  bb[2] <- floor(qv[1])
  } else {
  bb[2] <- lofence
  bb[1] <- qv[1]
  }
  if (upfence > qv[5]) { # no upper outliers
  bb[7] <- upfence
  bb[6] <- ceiling(qv[5])
  } else {
  bb[6] <- upfence
  bb[7] <- qv[5]
  }
  bb[3:5] <- qv[2:4]
  return(bb)
}


# Extract variable as vector out of dataframe
get.var <- function(vname, df) {
  v <- df[vname] # %>% sf::st_set_geometry(NULL)
  v <- unlist(v) # unname(v[,1])
  return(v)
}


# Boxmap function
boxmap <- function(vnam, df, mtitle, legtitle=NA, mult=1.5, palette='-RdBu') {
  df1 <- drop_na(df)
  var <- get.var(vnam,df1)
  bb <- boxbreaks(var)
  tm_shape(df) +
    tm_fill(vnam,
            title=legtitle,
            breaks=bb,
            palette="Blues",
            labels = c("Lower outlier", "< 25%", "25% - 50%", "50% - 75%","> 75%", "Upper outlier")) +
  tm_borders(lwd=0.1, alpha=1) +
  tm_layout(main.title = mtitle,
            main.title.position = 'center',
            main.title.size = 1.5,
            frame = TRUE,legend.title.size = 1.20, legend.text.size = 1.10, legend.position = c("left", "bottom")) +
  tm_compass(type="4star", size = 3) + 
  tm_scale_bar(width = 0.10, text.size = 0.90)+
  tm_grid(lwd = 0.1, alpha = 0.2, labels.size = 1.10) +
  tm_borders(alpha = 0.5)
}


# Boxmap function with points overlayed on top of choropleth map
boxmap_pts <- function(vnam, df, pointdf, mtitle, legtitle=NA, mult=1.5, palette='-RdBu') {
  boxmap(vnam, df, mtitle, legtitle=legtitle, mult=mult, palette=palette) +
  tm_shape(pointdf) +
    tm_dots(col="gray23")
}



```

We will now use the function using the previous constructed dataframe, Jakarta_Covid_Cases
to display summary statistics.

```{r echo = TRUE, eval = FALSE}
Covid_Cases_Boxmap <- boxmap("Cases Per 10k Population", Jakarta_Covid_Cases, mtitle="Boxmap of Jakarta Covid Cases, Mar 2020-July 2021")
Covid_Cases_Boxmap 
```

```{r fig.width=12, fig.height=8}

Covid_Cases_Boxmap <- boxmap("Cases Per 10k Population", Jakarta_Covid_Cases, mtitle="Boxmap of Jakarta Covid Cases, Mar 2020-July 2021")
Covid_Cases_Boxmap 
```


- The box map reveals that there are approximately more than 40 upper outliers (i.e. sub-district with extremely high COVID-19 cases per 10k population)

- Upper outliers are disperse geographically throughout Jakarta though more prominent in Central Jakarta

- To note, most upper outliers are closed to each others.

- There is no lower outlier.



### 12.3 Case Fatality Ratio (CFR) 

Case Fatality Ratio (CFR) estimates the proportion of deaths among identified 
confirmed cases.To verify one of the earlier stated hypothesis
that Covid-19 have low fatality rate, we will use the following formula:


$$ Case\ Fatality\ Rate\ = 
\frac{Total\ no\ of\ Covid-19\ Death\ at\ Sub-District\ 
Level}{Total\ Covid-19\ Cases\ of\ the\ Sub-District} *\ 100$$

The case fatality rate represents the proportion of cases that eventually die 
from a disease. Reliable CFRs that can be used to assess the deadliness of an 
outbreak and evaluate any implemented public health measures are generally 
obtained at the end of an outbreak, after all cases have been resolved (affected 
individuals either died or recovered). However, this calculation assumes that:

- The likelihood of detecting cases and deaths is consistent over the course of the outbreak.
- All detected cases have resolved (that is, reported cases have either recovered or died).

We will create a new dataframe called Merged_DF to calculate the CFR and we will
only be selecting the relevant column namely, cases, sub-district and death. 

The following code chunk will use left_join() of dplyr to join the geographical
data (DKI_Jakarta) and attribute table (Merged_DF) using sub-district e.g."Sub_District" as the common identifier.


Following which, it will be group by sub-district and we will calculate
Case Fatality Rate using summarise function of dplyr.

```{r echo=TRUE, eval=TRUE}


Merged_DF <- Covid_DF %>% select('Cases', 'Sub_District','Death')

Merged_DF<- left_join(DKI_Jakarta, Merged_DF, 
                      by= c("Sub_District" = "Sub_District")) %>% group_by (Sub_District) %>% dplyr::summarise(`Case Fatality Rate` = (sum(Death) / (sum(Cases))) *100) %>% ungroup()


```

Next, we will plot the result on the map using jenks classification method

```{r echo=TRUE, eval=TRUE}
tmap_mode("plot")+
  tm_shape(Merged_DF)+
  tm_fill("Case Fatality Rate",n = 5, style="jenks",
          legend.is.portrait = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Case Fatality Ratio (CFR) of Jakarta (Mar 2020- July 2021) ",
            main.title.position = "center",
            main.title.size = 0.75,title.size = 0.30,legend.title.size = 0.80, 
            legend.outside = FALSE,
            legend.position = c("left", "bottom"),
            frame = TRUE)+
  tm_compass(type="4star", size = 1.5) + 
  tm_scale_bar(width = 0.10)+
  tm_grid(lwd = 0.1, alpha = 0.2) 

```
- From the result, there appears to be difference in case fatality rate across sub-district in Jakarta 

- In line with earlier observation, CFR appears to be generally higher in Central Jakarta region

- Aforementioned in the introduction, the result of the CFR map is in line with the estimated 2% case fatality rate.

### 12.4 Excess Risk Map

A commonly used notion in demography and public health analysis is the concept 
of a standardized mortality rate (SMR), sometimes also referred to as relative 
risk or excess risk. The idea is to compare the observed mortality rate to a 
national (or regional) standard. More specifically, the observed number of 
events is compared to the number of events that would be expected had a reference 
risk been applied.

In our example, all the COVID-19 deaths in the sub-district over sub-district total population size. Formally, this is expressed as:

$$SMR= \frac{Number \ of \ observed \ deaths}{Number\ of\ expected\ deaths}$$


which yields the expected number of events for each area i as:


$$E_{i}=π∗P_{i}$$

The relative risk then follows as the ratio of the observed number of events 
(e.g., Covid death) over the expected number:

$$SMR_{i} = \frac{O_{i}}{E_{i}}$$


We start by calculating the reference rate, which is just the sum of events over the sum of the population.

First, we set the filter to the most recent month which is July 2021.

```{r echo=TRUE, eval=TRUE}

Covid_DF<- Covid_DF %>% filter(Date == "2021-07-31")


sum_observed <- sum(Covid_DF$Death)
sum_population <- sum(DKI_Jakarta$Total_Population)
p_i <- sum_observed / sum_population

```

Next we calculate the expected number of events for each sub-district based on the reference rate for the whole Jakarta and the population for each sub-district.

```{r echo=TRUE, eval=TRUE}
E_i <- p_i * DKI_Jakarta$Total_Population
```

We will divide the actual count by the expected count to get the relative risk rate. This ratio will show us which sub-district have a higher than expected number of Covid-19 death, and which sub-district have a lower than expected count.

```{r echo=TRUE, eval=TRUE}
Covid_DF$smr <- Covid_DF$Death / E_i
```

Next, we will group by date and sub-district and do a left_join 
using common identifier 'Sub-District' and omit the na fields and convert into
sf. 

```{r echo=TRUE, eval=TRUE}
Covid_DF <- Covid_DF %>% group_by(Date, Sub_District)

Jakarta_Covid_smr<- Covid_DF %>%
  left_join(DKI_Jakarta, by=c("Sub_District"="Sub_District"))

Jakarta_Covid_smr <- na.omit(Jakarta_Covid_smr,c("smr"))

Jakarta_Covid_smr<- st_as_sf(Jakarta_Covid_smr)

Jakarta_Covid_smr<- Jakarta_Covid_smr  %>% ungroup()

```

Afterwhich, we will plot the map using tmp_fill() with the variable 'smr' 

```{r echo=TRUE, eval=TRUE}


  
tm_shape(Jakarta_Covid_smr) +
     tm_fill("smr",title="Excess risk", breaks=c(-100,.25,.5,1,2,4,1000),labels = c("<.25", ".25 - .50", ".50 - 1.00","1.00 - 2.00", "2.00 - 4.00", "> 4.00" ), palette = "OrRd")  +
  tm_layout(legend.show = TRUE, 
            main.title.size = 1,main.title = "Excess Risk Rate In Jakarta Sub-District (July 2021)", legend.outside = FALSE,legend.width = 0.70, legend.text.size = 0.80, legend.title.size = 1.00, legend.position = c("left", "bottom"))+
  tm_compass(type="4star", size = 0.9) + 
  tm_scale_bar(width = 0.09,text.size = 0.60)+
  tm_grid(lwd = 0.1, alpha = 0.2,labels.size=0.70) +
  tm_borders(alpha = 0.5)



```

- In the excess risk map, pale pink sub-district s will indicate a risk lower than Jakarta average, or SMR<1. Red sub-district indicate a risk higher than the Jakarta average, or SMR>1.

- From the excess risk map, we can observe that a few sub-district in Central Jakarta region has lower excess risk level (<0.50)
compared to other region. A possible explanation for this observation may be due to the fact that the 6 main COVID-19 specialized 
hospital are located in central Jakarta hence mortality rate is lower, though further statistical test need to be carried out.  

- Amongst all the sub-district in Jakarta, we can see that sub-district in North Jakarta appears to be experiencing
higher excess risk of mostly >2 compared to other region in Jakarta 


## 13. Localised Geospatial Statistic

### 13.1 Data Preparation

First, we will filter the time period of interest which are:

- March 2020
- March 2021

The time period is chosen based on 1 year after the onset of COVID-19 in Jakarta. 

First, we will filter the data according to date - "2020-03-31" and "2021-03-31"
and create a new dataframe name Jakarta_Covid_Cases_March20 and Jakarta_Covid_Cases_March21
respectively.


Next, data will be converted to the sp class to facilitate data analysis in this section.

```{r echo=TRUE, eval=TRUE}


Jakarta_Covid_Cases_March20 <- Jakarta_Covid_Cases %>% filter(Date == "2020-03-31")

Jakarta_Covid_Cases_March21 <- Jakarta_Covid_Cases %>% filter(Date == "2021-03-31")


Jakarta_Covid_Cases_March21_sp <- as(Jakarta_Covid_Cases_March21, 'Spatial')
Jakarta_Covid_Cases_March20_sp <- as(Jakarta_Covid_Cases_March20, 'Spatial')
```

### 13.2 Define Weight Matrix

Before the analysis can be conducted, the weight matrix will first to have to 
defined for sub-district in Jakarta. The neighbourhood structure of sub-districts
will be codified using contiguity weight matrices to express the spatial 
dependency between the sub-districts 


#### 13.2.1 Compute rook contiguity weight matrix

```{r echo=TRUE, eval=TRUE}
JK_Covid <- poly2nb(Jakarta_Covid_Cases_March21_sp, queen=FALSE)
summary(JK_Covid)
```

- The most connected sub-district has 10 neighbours.
- There are 5 sub-districts which are the least connected with only 2 neighbours.

#### 13.2.2 Compute queen contiguity weight matrix

```{r echo=TRUE, eval=TRUE}
JK_queen <- poly2nb(Jakarta_Covid_Cases_March21_sp, queen=TRUE)
summary(JK_queen)
```
- The most connected sub-district has 11 neighbours.
- There are 5 sub-district which are the least connected with only 2 neighbour which
is similar to rook contiguity weight matrix.

#### 13.2.3 Compute number of regions with no neighbours

```{r echo=TRUE, eval=TRUE}
print(paste0('Rook contiguity: There are ', length(which(card(JK_Covid)==0)), ' sub-district(s) with no neighbours.'))
```

```{r echo=TRUE, eval=TRUE}
print(paste0('Queen contiguity: There are ', length(which(card(JK_queen)==0)), ' sub-district(s) with no neighbours.'))
```
- All sub-district had at least one neighbour.

#### 13.2.4 Distribution of the number of neighbours for sub-district 

- First we will create data frame using neighbour list for queen contiguity weight matrix.

- For each number of neighbour, count the number of sub-district having that number of neighbouring sub-district

- Next, we will create bar chart visualising the distribution of number of neighbours usin ggplot

```{r echo=TRUE, eval=TRUE}


JK_DF <- data.frame('Neighbours' = card(JK_queen)) %>%
  group_by(Neighbours) %>%
  dplyr::summarise(Count = n())
JK_DF[is.na(JK_DF)] = 0

ggplot(JK_DF, aes(x = Neighbours, y = Count)) +
  geom_col(fill = 'slategray3') +
  labs(title = 'Distribution of Number of Neighbours for Sub-district',
       x = 'Number of Neighbours',
       y = 'Number of Sub-district') +
  theme_minimal() +
  theme(axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
        axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)),
        plot.title = element_text(margin = margin(t = 0, r = 0, b = 20, l = 0)))
```

- Although all sub-district had at least one neighbour, majority of the sub-district only have small number of neighbours (6 and below) which might not lead to stable and statistically significant results. 


#### 13.2.5 Plot of Queen contiguity neighbour map


```{r echo=TRUE, eval=TRUE}
plot(Jakarta_Covid_Cases_March21_sp, border="lightgrey")
plot(JK_queen, coordinates(Jakarta_Covid_Cases_March21_sp), pch = 19, cex = 0.6, add = TRUE, col= "red")
```

- From the plot, the use of contiguity based methods lead to edge effects, where sub-district at the edge e,g Northern Jakarta region only have a small number of neighbours.

- Furthermore, it must be noted from the plot that large sub-district surrounded by smaller sub-districts will have far greater number of neighbours than its neighbouring zones

- Considering the context of the analysis, COVID-19 is spread through contact and respiratory droplets. Hence for the sub-district in this analysis, being located at a certain distance from one another is more important than being located on which side of the boundary.

- Thus, we will look into distance-based methods for computing the weight matrix.


#### 13.3 Distance-based weight matrices

```{r echo=TRUE, eval=TRUE}

coords <- coordinates(Jakarta_Covid_Cases_March20_sp)

```



##### 13.3.1  Adaptive distance

As COVID-19 rates were observed to be slightly skewed in earlier analysis,
sub-district should be evaluated in the context of at approximately neighbours 
for results to be stable.

Noting that with the selection of more neighbours (higher k), spatial patterns 
become increasingly homogenised, 9 nearest neighbours are chosen for the 
computation of the adaptive distance matrix.

The following code chunk will compute adaptive distance matrix of 9 nearest 
neighbours

###### 13.3.1.1 Compute adaptive distance matrix of 9 nearest neighbours


```{r echo=TRUE, eval=TRUE}

wm_knn9 <- knn2nb(knearneigh(coords, k=9))
wm_knn9

```

- Each sub-district has 9 neighbours, there are no sub-district with no neighbours.


###### 13.3.1.2 Summary statistics of neighbour distances with 9 nearest neighbours

```{r echo=TRUE, eval=TRUE}
k9dists <- unlist(nbdists(wm_knn9, coords))
summary(k9dists)
```

- Using 9 nearest neighbours, the maximum distance between neighbours is 8800m 
which is a reasonable distance for citizens to engage in social interaction 
with one another which may then lead to the spread of COVID-19.


###### 13.3.1.3 Adaptive distance neighbour map

```{r echo=TRUE, eval=TRUE}

plot(Jakarta_Covid_Cases_March20_sp, border="lightgrey")
plot(wm_knn9, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```
### 13.3 Local Moran’s I

Local Moran’s I (a local spatial autocorrelation indicator - LISA) will be 
utilised to detect spatial clusters of sub-district with high or low COVID-19 
cases per 10k population rates, and detect outliers. The analysis will be 
conducted from Mar 2020 to Mar 2021 to better analyse and understand spatial 
clusters and outliers across time.

Interpretation of local Moran’s I values

- Ii<0: indicates negative spatial local autocorrelation, suggesting a combination of dissimilar values (high values surrounded by low values, or low values surrounded by high values)

- Ii>0: indicates positive spatial local autocorrelation, suggesting a grouping of similar values (that are higher or lower than average)


#### 13.3.1 Compute row-standardised weight matrix

The sum of weights of its neighbours for a particular sub-district is equal to 1.

The row-standardised weight matrix will be constructed as follow:

- Weights are assigned to each neighbouring sub-district and standardised.

- In a row-standardised weight matrix: For a particular sub-district, each 
neighbouring sub-district is assigned a fraction of 1 / Total number of neighbours. 
Each weight can thus be interpreted as the fraction of spatial influence on the 
particular sub-district that is ascribable to the neighbouring sub-district.

- With weights assigned to each neighbour, in the computation of average 
neighbouring COVID-19 case per 10k population rate, each neighbour’s COVID-19 
rate will be multiplied by its weight (1 / Total number of neighbours), then tallied.

```{r echo=TRUE, eval=TRUE}

rswm_knn9 <- nb2listw(wm_knn9, style = 'W')
rswm_knn9
```

#### 13.3.2 Compute Local Moran’s I of COVID-19 Case Per 10k Population rate at the sub-district level for Mar 2020 and Mar 2021

```{r echo=TRUE, eval=TRUE}


localmoran_Mar20 <- localmoran(Jakarta_Covid_Cases_March20_sp$Cases.Per.10k.Population, rswm_knn9)
localmoran_Mar21 <- localmoran(Jakarta_Covid_Cases_March21_sp$Cases.Per.10k.Population, rswm_knn9)

JKT_localmoran_Mar20  <- cbind(Jakarta_Covid_Cases_March20_sp, localmoran_Mar20)
JKT_localmoran_Mar21  <- cbind(Jakarta_Covid_Cases_March21_sp , localmoran_Mar21)

```

Here is the coefficients for Local Moran’s I for Mar 2020 for the first 5 sub-district

- Ii: local Moran statistic
- E.Ii: expectation of local Moran statistic
- Var.Ii: variance of local Moran statistic
- Z.Ii: standard deviate of local Moran statistic
- Pr(): p-value of local Moran statistic

```{r echo=TRUE, eval=TRUE}
head(JKT_localmoran_Mar20, 5)
```
Here is the coefficients for Local Moran’s I for Mar 2021 for the first 5 sub-district

```{r echo=TRUE, eval=TRUE}

head(JKT_localmoran_Mar21, 5)
```
#### 13.3.3 Map Local Moran’s I

To enable a better understanding of the calculated scores, local Moran’s I 
scores for Mar 2020 and Mar 2021 are visualised on a choropleth map.

Here is the function for constructing the choropleth map and we will be using
tmap_fill with the column Ii:

```{r echo=TRUE, eval=TRUE}
localmoran_map <- function(df, Date) {
  tm_shape(df) +
  tm_fill(col = "Ii", 
          style = "pretty",
          palette = "RdBu",
          title = 'Local Moran \nStatistics') +
  tm_borders(alpha = 0.5) +
  tm_layout(panel.labels = sprintf('Local Moran\'s I,%s', Date),
            panel.label.color = 'gray12',,legend.title.size = 2.75, legend.text.size = 2.55, title.size=3, panel.label.size = 3)+
  tm_compass(type="4star", size = 4) + 
  tm_scale_bar(width = 0.15,text.size = 2.30) +
  tm_grid(lwd = 0.1, alpha = 0.2, labels.size = 1.50) 
}



```

Plotting the map and arranging the map using tmap_arrange()

```{r echo = TRUE, eval = FALSE}
moranplot_13 <- localmoran_map(JKT_localmoran_Mar20, "Mar 2020")
moranplot_32 <- localmoran_map(JKT_localmoran_Mar21, "Mar 2021")
tmap_arrange(moranplot_13, moranplot_32)

```

```{r fig.width=20, fig.height=15}
moranplot_13 <- localmoran_map(JKT_localmoran_Mar20, "Mar 2020")
moranplot_32 <- localmoran_map(JKT_localmoran_Mar21, "Mar 2021")
tmap_arrange(moranplot_13, moranplot_32)

```
- Blue areas (positive local Moran’s I) indicate positive spatial local autocorrelation
- Red areas (negative local Moran’s I) indicate negative spatial local autocorrelation.
- The choropleth local Moran’s I plot both positive and negative local Moran’s I values 
during the study period


We will now consider the local Moran statistics with its corresponding p-values, to interpret if the values have statistical significance.
As such, local Moran’s I values and the corresponding p-values will be visualised spatially side-by-side to understand sub-district which have local Moran’s I values that are statistically significant.


The following code chunk is a function to construct p-value map:

```{r echo=TRUE, eval=TRUE}

pvalue_map <- function(df, Date) {
  tm_shape(df) +
  tm_fill(col = "Pr.z...0.", 
          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
          palette = "-Blues",
          title = 'P-values', title.size=2.8)+
  tm_compass(type="4star", size = 4) + 
  tm_scale_bar(width = 0.15,text.size = 2.30)+
  tm_grid(lwd = 0.1, alpha = 0.2,labels.size=1.50)+
  tm_borders(alpha = 0.5) +
  tm_layout(panel.labels = sprintf('Local Moran\'s I p-values,%s', Date),
            panel.label.color = 'gray12', legend.outside = FALSE,legend.title.size = 2.75, legend.text.size = 2.55, panel.label.size = 3)
}
```

Plotting the map

```{r echo = TRUE, eval = FALSE}
tmap_arrange(moranplot_13, pvalue_map(JKT_localmoran_Mar20, "March 2020"),
             moranplot_32, pvalue_map(JKT_localmoran_Mar21, "March 2021"),
             ncol=2)
         
``` 

```{r fig.width=20, fig.height=30}
tmap_arrange(moranplot_13, pvalue_map(JKT_localmoran_Mar20, "March 2020"),
             moranplot_32, pvalue_map(JKT_localmoran_Mar21, "March 2021"),
             ncol=2)
             
```             

*March 2020*

-  Relatively high and positive local Moran’s I values as indicated by darker blue areas on the local Moran’s I plot
March 2021 around Karet Semmangi 

- These values are statistically significant at 99.9% confidence level, with p-values of less than 0.001 indicated 
by the corresponding areas that are in darkest shade of blue at the p-value plot.

- From the result, we can onserve that there is significant and positive local autocorrelation for COVID-19 case per 10k population at these bordering sub-district, suggesting a grouping of sub-district with COVID-19 rates that are higher than average for these bordering sub-districts during March 2020.


*March 2021*

One year after onset of COVID-19, sub-district with positive and relatively higher Moran’s I values are statistically significant at 99.9% confidence level (p-value less than 0.001).

There is therefore significant and positive local autocorrelation for COVID-19 cases per 10k population rate at sub-district in March 2021, suggesting that this group of sub-district are a cluster for COVID-19 at March 2021, with COVID-19 rates that are higher than average.



## 14. Conclusion

Through the different analysis, the following observations were made:

*Spatial-temporal patterns of Covid-19 Cases and how they change over time.*

-	COVID-19 cases seem to spread outwards to the neighbouring sub-district with time as seen from the time-series choropleth map of Covid-19 rate 

-	Significant and positive local autocorrelation for COVID-19 case per 10k population at bordering sub-district, suggesting a grouping of sub-district with COVID-19 rates that are higher than average for bordering sub-districts during March 2020.

-	Significant and positive local autocorrelation for COVID-19 cases per 10k population rate at sub-district in March 2021, suggesting that this group of sub-district are a cluster for COVID-19 at March 2021, with COVID-19 rates that are higher than average.


*Sub-districts with relatively higher number of confirmed cases*

-  In descending order of Covid rate per 10k population: Gambir, Senayan and Gunung were found to be the sub-district most affected by COVID-19 

- Through our Standardized Mortality Rate geospatial analysis, sub-district in North Jakarta appears to be experiencing
higher excess risk of mostly >2 compared to other region in Jakarta which may serve as a warning for local public health authority

## 15. References

- [Standardized Mortality Rate (SMR)](https://spatialanalysis.github.io/lab_tutorials/Rate_mapping.html#spatially-extensive-and-intensive-variables)

- [Jakarta Covid-19 Timeline](https://corona.jakarta.go.id/en/artikel/linimasa-kebijakan-penanganan-pandemi-covid-19-di-jakarta)

- [Transmission Method of Covid-19](https://www.straitstimes.com/singapore/how-covid-19-led-to-spores-clusters-airborne-droplet-or-surface-transmission)

- [Past Covid-19 Analysis](https://rpubs.com/xiaorongw/IS415_Take-home_Ex02)

- [Case Mortality Rate](https://www.who.int/news-room/commentaries/detail/estimating-mortality-from-covid-19)

- [Delta Variant in Jakarta](https://indonesien.ahk.de/infothek/news/news-details/covid-19-developments-in-indonesia)


