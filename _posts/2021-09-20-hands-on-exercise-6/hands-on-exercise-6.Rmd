---
title: "In-Class Exercise 6"
description: |
    In this hands-on exercise, I will derive spatial weights by using functions provided by spdep package and appliy these spatial weights to compute geographically referenced attributes.
author:
  - name: Lye Jia Wei
    url: https://lye-jia-wei.github.io/
date: 09-20-2021
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Useful Reference

[R-spatial](https://rspatial.github.io/raster/reference/index.html)

- poly2nb() is to create proximity spatial weight
- Knearneigh() to construct distance matrix and define neighbour 
  + Fixed Kernel
  + Adaptive Kernel 
- nb2listw() to convert so spatial weight

In this hands-on exercise, we will compute spatial weights using R

- import geospatial 

## Getting Started

In this hands-on exercise, the following r packages will be used :

- import geospatial data using appropriate function(s) of rgdal package,
- import csv file using appropriate function of readr package,
- perform relational join using appropriate join function of dplyr package,
- compute spatial weights using appropriate R functions, and
- calculate spatially lag attributes using appropriate functions of spdep package.

```{r}
packages = c('sf', 'spdep', 'tmap', 'tidyverse')
for (p in packages){
  if(!require(p, character.only = T)){
    install.packages(p)
  }
  library(p,character.only = T)
}
```

## Loading Data Into R 

### Import shapefile into r environment

The code chunk below uses st_read() of sf package to import Hunan shapefile into R. The imported shapefile will be simple features Object of sf.

```{r}
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
```

### Import csv file into r environment

Next, we will import Hunan_2012.csv into R by using read_csv() of readr package. The output is R dataframe class.

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

There is a total of 29 variables 

## Performing relational join

The code chunk below will be used to update the attribute table of hunanâ€™s SpatialPolygonsDataFrame with the attribute fields of hunan2012 dataframe. This is performed by using left_join() of dplyr package.

```{r}
hunan <- left_join(hunan,hunan2012)
```

Now there are 36 variables 

## Visualising Regional Development Indicator

Now, we are going to prepare a basemap and choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.

```{r fig.width=26, fig.height=15}
basemap <-tm_shape(hunan) + tm_polygons() + tm_text("NAME_3", size=1)

gdppc <- qtm(hunan, "GDPPC")+
tm_layout(legend.outside = FALSE,legend.title.size = 2.10, legend.text.size = 1.90)
tmap_arrange(basemap,gdppc,asp=1,ncol=2)
```

## Computing Contiguity Spatial Weights

### Computing (QUEEN) contiguity based neighbours


The code chunk below is used to compute Queen contiguity weight matrix.

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

Polygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.

We can retrive the county name of Polygon ID=1 by using the code chunk below:

```{r}
hunan$County[1]
```

The output reveals that Polygon ID=1 is Anxiang county.

To reveal the count names of the five neighboring polygons, the code chunk will be used:

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

We can retrieve the GDPPC of these five counties by using the code chunk below
```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

## Plotting Hisogram to visualize distribution 

```{r}
hist(hunan$GDPPC)
```

From the output we can see that it is right skewed 


## Visualising contiguity weights

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

We do the same for latitude with one key difference. We access the second value per each centroid with [[2]].

```{r}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```


Use cbind to put longitude and latitude into the same object.

```{r}
coords <- cbind(longitude, latitude)
```

Plotting Queen contiguity based neighbours maps

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```
Plotting Rook contiguity based neighbours maps

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red", main="Queen Contiguity")
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red", main="Rook Contiguity")
```

